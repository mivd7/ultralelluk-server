module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.1). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateComment {
  count: Int!
}

type AggregateGig {
  count: Int!
}

type AggregateMedia {
  count: Int!
}

type AggregatePost {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Comment {
  id: ID!
  text: String!
  writtenBy: User!
  media: Media
  post: Post
  gig: Gig
}

type CommentConnection {
  pageInfo: PageInfo!
  edges: [CommentEdge]!
  aggregate: AggregateComment!
}

input CommentCreateInput {
  id: ID
  text: String!
  writtenBy: UserCreateOneWithoutCommentsInput!
  media: MediaCreateOneWithoutCommentsInput
  post: PostCreateOneWithoutCommentsInput
  gig: GigCreateOneWithoutCommentsInput
}

input CommentCreateManyWithoutGigInput {
  create: [CommentCreateWithoutGigInput!]
  connect: [CommentWhereUniqueInput!]
}

input CommentCreateManyWithoutMediaInput {
  create: [CommentCreateWithoutMediaInput!]
  connect: [CommentWhereUniqueInput!]
}

input CommentCreateManyWithoutPostInput {
  create: [CommentCreateWithoutPostInput!]
  connect: [CommentWhereUniqueInput!]
}

input CommentCreateManyWithoutWrittenByInput {
  create: [CommentCreateWithoutWrittenByInput!]
  connect: [CommentWhereUniqueInput!]
}

input CommentCreateWithoutGigInput {
  id: ID
  text: String!
  writtenBy: UserCreateOneWithoutCommentsInput!
  media: MediaCreateOneWithoutCommentsInput
  post: PostCreateOneWithoutCommentsInput
}

input CommentCreateWithoutMediaInput {
  id: ID
  text: String!
  writtenBy: UserCreateOneWithoutCommentsInput!
  post: PostCreateOneWithoutCommentsInput
  gig: GigCreateOneWithoutCommentsInput
}

input CommentCreateWithoutPostInput {
  id: ID
  text: String!
  writtenBy: UserCreateOneWithoutCommentsInput!
  media: MediaCreateOneWithoutCommentsInput
  gig: GigCreateOneWithoutCommentsInput
}

input CommentCreateWithoutWrittenByInput {
  id: ID
  text: String!
  media: MediaCreateOneWithoutCommentsInput
  post: PostCreateOneWithoutCommentsInput
  gig: GigCreateOneWithoutCommentsInput
}

type CommentEdge {
  node: Comment!
  cursor: String!
}

enum CommentOrderByInput {
  id_ASC
  id_DESC
  text_ASC
  text_DESC
}

type CommentPreviousValues {
  id: ID!
  text: String!
}

input CommentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  AND: [CommentScalarWhereInput!]
  OR: [CommentScalarWhereInput!]
  NOT: [CommentScalarWhereInput!]
}

type CommentSubscriptionPayload {
  mutation: MutationType!
  node: Comment
  updatedFields: [String!]
  previousValues: CommentPreviousValues
}

input CommentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CommentWhereInput
  AND: [CommentSubscriptionWhereInput!]
  OR: [CommentSubscriptionWhereInput!]
  NOT: [CommentSubscriptionWhereInput!]
}

input CommentUpdateInput {
  text: String
  writtenBy: UserUpdateOneRequiredWithoutCommentsInput
  media: MediaUpdateOneWithoutCommentsInput
  post: PostUpdateOneWithoutCommentsInput
  gig: GigUpdateOneWithoutCommentsInput
}

input CommentUpdateManyDataInput {
  text: String
}

input CommentUpdateManyMutationInput {
  text: String
}

input CommentUpdateManyWithoutGigInput {
  create: [CommentCreateWithoutGigInput!]
  delete: [CommentWhereUniqueInput!]
  connect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  disconnect: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutGigInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutGigInput!]
  deleteMany: [CommentScalarWhereInput!]
  updateMany: [CommentUpdateManyWithWhereNestedInput!]
}

input CommentUpdateManyWithoutMediaInput {
  create: [CommentCreateWithoutMediaInput!]
  delete: [CommentWhereUniqueInput!]
  connect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  disconnect: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutMediaInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutMediaInput!]
  deleteMany: [CommentScalarWhereInput!]
  updateMany: [CommentUpdateManyWithWhereNestedInput!]
}

input CommentUpdateManyWithoutPostInput {
  create: [CommentCreateWithoutPostInput!]
  delete: [CommentWhereUniqueInput!]
  connect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  disconnect: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutPostInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutPostInput!]
  deleteMany: [CommentScalarWhereInput!]
  updateMany: [CommentUpdateManyWithWhereNestedInput!]
}

input CommentUpdateManyWithoutWrittenByInput {
  create: [CommentCreateWithoutWrittenByInput!]
  delete: [CommentWhereUniqueInput!]
  connect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  disconnect: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutWrittenByInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutWrittenByInput!]
  deleteMany: [CommentScalarWhereInput!]
  updateMany: [CommentUpdateManyWithWhereNestedInput!]
}

input CommentUpdateManyWithWhereNestedInput {
  where: CommentScalarWhereInput!
  data: CommentUpdateManyDataInput!
}

input CommentUpdateWithoutGigDataInput {
  text: String
  writtenBy: UserUpdateOneRequiredWithoutCommentsInput
  media: MediaUpdateOneWithoutCommentsInput
  post: PostUpdateOneWithoutCommentsInput
}

input CommentUpdateWithoutMediaDataInput {
  text: String
  writtenBy: UserUpdateOneRequiredWithoutCommentsInput
  post: PostUpdateOneWithoutCommentsInput
  gig: GigUpdateOneWithoutCommentsInput
}

input CommentUpdateWithoutPostDataInput {
  text: String
  writtenBy: UserUpdateOneRequiredWithoutCommentsInput
  media: MediaUpdateOneWithoutCommentsInput
  gig: GigUpdateOneWithoutCommentsInput
}

input CommentUpdateWithoutWrittenByDataInput {
  text: String
  media: MediaUpdateOneWithoutCommentsInput
  post: PostUpdateOneWithoutCommentsInput
  gig: GigUpdateOneWithoutCommentsInput
}

input CommentUpdateWithWhereUniqueWithoutGigInput {
  where: CommentWhereUniqueInput!
  data: CommentUpdateWithoutGigDataInput!
}

input CommentUpdateWithWhereUniqueWithoutMediaInput {
  where: CommentWhereUniqueInput!
  data: CommentUpdateWithoutMediaDataInput!
}

input CommentUpdateWithWhereUniqueWithoutPostInput {
  where: CommentWhereUniqueInput!
  data: CommentUpdateWithoutPostDataInput!
}

input CommentUpdateWithWhereUniqueWithoutWrittenByInput {
  where: CommentWhereUniqueInput!
  data: CommentUpdateWithoutWrittenByDataInput!
}

input CommentUpsertWithWhereUniqueWithoutGigInput {
  where: CommentWhereUniqueInput!
  update: CommentUpdateWithoutGigDataInput!
  create: CommentCreateWithoutGigInput!
}

input CommentUpsertWithWhereUniqueWithoutMediaInput {
  where: CommentWhereUniqueInput!
  update: CommentUpdateWithoutMediaDataInput!
  create: CommentCreateWithoutMediaInput!
}

input CommentUpsertWithWhereUniqueWithoutPostInput {
  where: CommentWhereUniqueInput!
  update: CommentUpdateWithoutPostDataInput!
  create: CommentCreateWithoutPostInput!
}

input CommentUpsertWithWhereUniqueWithoutWrittenByInput {
  where: CommentWhereUniqueInput!
  update: CommentUpdateWithoutWrittenByDataInput!
  create: CommentCreateWithoutWrittenByInput!
}

input CommentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  writtenBy: UserWhereInput
  media: MediaWhereInput
  post: PostWhereInput
  gig: GigWhereInput
  AND: [CommentWhereInput!]
  OR: [CommentWhereInput!]
  NOT: [CommentWhereInput!]
}

input CommentWhereUniqueInput {
  id: ID
}

scalar DateTime

type Gig {
  id: ID!
  date: DateTime!
  time: String!
  title: String!
  confirmed: Boolean
  done: Boolean
  participants(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment!]
  media(where: MediaWhereInput, orderBy: MediaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Media!]
}

type GigConnection {
  pageInfo: PageInfo!
  edges: [GigEdge]!
  aggregate: AggregateGig!
}

input GigCreateInput {
  id: ID
  date: DateTime!
  time: String!
  title: String!
  confirmed: Boolean
  done: Boolean
  participants: UserCreateManyWithoutShowsInput
  comments: CommentCreateManyWithoutGigInput
  media: MediaCreateManyInput
}

input GigCreateManyWithoutParticipantsInput {
  create: [GigCreateWithoutParticipantsInput!]
  connect: [GigWhereUniqueInput!]
}

input GigCreateOneWithoutCommentsInput {
  create: GigCreateWithoutCommentsInput
  connect: GigWhereUniqueInput
}

input GigCreateWithoutCommentsInput {
  id: ID
  date: DateTime!
  time: String!
  title: String!
  confirmed: Boolean
  done: Boolean
  participants: UserCreateManyWithoutShowsInput
  media: MediaCreateManyInput
}

input GigCreateWithoutParticipantsInput {
  id: ID
  date: DateTime!
  time: String!
  title: String!
  confirmed: Boolean
  done: Boolean
  comments: CommentCreateManyWithoutGigInput
  media: MediaCreateManyInput
}

type GigEdge {
  node: Gig!
  cursor: String!
}

enum GigOrderByInput {
  id_ASC
  id_DESC
  date_ASC
  date_DESC
  time_ASC
  time_DESC
  title_ASC
  title_DESC
  confirmed_ASC
  confirmed_DESC
  done_ASC
  done_DESC
}

type GigPreviousValues {
  id: ID!
  date: DateTime!
  time: String!
  title: String!
  confirmed: Boolean
  done: Boolean
}

input GigScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  time: String
  time_not: String
  time_in: [String!]
  time_not_in: [String!]
  time_lt: String
  time_lte: String
  time_gt: String
  time_gte: String
  time_contains: String
  time_not_contains: String
  time_starts_with: String
  time_not_starts_with: String
  time_ends_with: String
  time_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  confirmed: Boolean
  confirmed_not: Boolean
  done: Boolean
  done_not: Boolean
  AND: [GigScalarWhereInput!]
  OR: [GigScalarWhereInput!]
  NOT: [GigScalarWhereInput!]
}

type GigSubscriptionPayload {
  mutation: MutationType!
  node: Gig
  updatedFields: [String!]
  previousValues: GigPreviousValues
}

input GigSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GigWhereInput
  AND: [GigSubscriptionWhereInput!]
  OR: [GigSubscriptionWhereInput!]
  NOT: [GigSubscriptionWhereInput!]
}

input GigUpdateInput {
  date: DateTime
  time: String
  title: String
  confirmed: Boolean
  done: Boolean
  participants: UserUpdateManyWithoutShowsInput
  comments: CommentUpdateManyWithoutGigInput
  media: MediaUpdateManyInput
}

input GigUpdateManyDataInput {
  date: DateTime
  time: String
  title: String
  confirmed: Boolean
  done: Boolean
}

input GigUpdateManyMutationInput {
  date: DateTime
  time: String
  title: String
  confirmed: Boolean
  done: Boolean
}

input GigUpdateManyWithoutParticipantsInput {
  create: [GigCreateWithoutParticipantsInput!]
  delete: [GigWhereUniqueInput!]
  connect: [GigWhereUniqueInput!]
  set: [GigWhereUniqueInput!]
  disconnect: [GigWhereUniqueInput!]
  update: [GigUpdateWithWhereUniqueWithoutParticipantsInput!]
  upsert: [GigUpsertWithWhereUniqueWithoutParticipantsInput!]
  deleteMany: [GigScalarWhereInput!]
  updateMany: [GigUpdateManyWithWhereNestedInput!]
}

input GigUpdateManyWithWhereNestedInput {
  where: GigScalarWhereInput!
  data: GigUpdateManyDataInput!
}

input GigUpdateOneWithoutCommentsInput {
  create: GigCreateWithoutCommentsInput
  update: GigUpdateWithoutCommentsDataInput
  upsert: GigUpsertWithoutCommentsInput
  delete: Boolean
  disconnect: Boolean
  connect: GigWhereUniqueInput
}

input GigUpdateWithoutCommentsDataInput {
  date: DateTime
  time: String
  title: String
  confirmed: Boolean
  done: Boolean
  participants: UserUpdateManyWithoutShowsInput
  media: MediaUpdateManyInput
}

input GigUpdateWithoutParticipantsDataInput {
  date: DateTime
  time: String
  title: String
  confirmed: Boolean
  done: Boolean
  comments: CommentUpdateManyWithoutGigInput
  media: MediaUpdateManyInput
}

input GigUpdateWithWhereUniqueWithoutParticipantsInput {
  where: GigWhereUniqueInput!
  data: GigUpdateWithoutParticipantsDataInput!
}

input GigUpsertWithoutCommentsInput {
  update: GigUpdateWithoutCommentsDataInput!
  create: GigCreateWithoutCommentsInput!
}

input GigUpsertWithWhereUniqueWithoutParticipantsInput {
  where: GigWhereUniqueInput!
  update: GigUpdateWithoutParticipantsDataInput!
  create: GigCreateWithoutParticipantsInput!
}

input GigWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  time: String
  time_not: String
  time_in: [String!]
  time_not_in: [String!]
  time_lt: String
  time_lte: String
  time_gt: String
  time_gte: String
  time_contains: String
  time_not_contains: String
  time_starts_with: String
  time_not_starts_with: String
  time_ends_with: String
  time_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  confirmed: Boolean
  confirmed_not: Boolean
  done: Boolean
  done_not: Boolean
  participants_every: UserWhereInput
  participants_some: UserWhereInput
  participants_none: UserWhereInput
  comments_every: CommentWhereInput
  comments_some: CommentWhereInput
  comments_none: CommentWhereInput
  media_every: MediaWhereInput
  media_some: MediaWhereInput
  media_none: MediaWhereInput
  AND: [GigWhereInput!]
  OR: [GigWhereInput!]
  NOT: [GigWhereInput!]
}

input GigWhereUniqueInput {
  id: ID
}

scalar Long

type Media {
  id: ID!
  src: String!
  caption: String
  catogories: String
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment!]
  submittedBy: User
  isVideo: Boolean
}

type MediaConnection {
  pageInfo: PageInfo!
  edges: [MediaEdge]!
  aggregate: AggregateMedia!
}

input MediaCreateInput {
  id: ID
  src: String!
  caption: String
  catogories: String
  comments: CommentCreateManyWithoutMediaInput
  submittedBy: UserCreateOneWithoutMediaInput
  isVideo: Boolean
}

input MediaCreateManyInput {
  create: [MediaCreateInput!]
  connect: [MediaWhereUniqueInput!]
}

input MediaCreateManyWithoutSubmittedByInput {
  create: [MediaCreateWithoutSubmittedByInput!]
  connect: [MediaWhereUniqueInput!]
}

input MediaCreateOneWithoutCommentsInput {
  create: MediaCreateWithoutCommentsInput
  connect: MediaWhereUniqueInput
}

input MediaCreateWithoutCommentsInput {
  id: ID
  src: String!
  caption: String
  catogories: String
  submittedBy: UserCreateOneWithoutMediaInput
  isVideo: Boolean
}

input MediaCreateWithoutSubmittedByInput {
  id: ID
  src: String!
  caption: String
  catogories: String
  comments: CommentCreateManyWithoutMediaInput
  isVideo: Boolean
}

type MediaEdge {
  node: Media!
  cursor: String!
}

enum MediaOrderByInput {
  id_ASC
  id_DESC
  src_ASC
  src_DESC
  caption_ASC
  caption_DESC
  catogories_ASC
  catogories_DESC
  isVideo_ASC
  isVideo_DESC
}

type MediaPreviousValues {
  id: ID!
  src: String!
  caption: String
  catogories: String
  isVideo: Boolean
}

input MediaScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  src: String
  src_not: String
  src_in: [String!]
  src_not_in: [String!]
  src_lt: String
  src_lte: String
  src_gt: String
  src_gte: String
  src_contains: String
  src_not_contains: String
  src_starts_with: String
  src_not_starts_with: String
  src_ends_with: String
  src_not_ends_with: String
  caption: String
  caption_not: String
  caption_in: [String!]
  caption_not_in: [String!]
  caption_lt: String
  caption_lte: String
  caption_gt: String
  caption_gte: String
  caption_contains: String
  caption_not_contains: String
  caption_starts_with: String
  caption_not_starts_with: String
  caption_ends_with: String
  caption_not_ends_with: String
  catogories: String
  catogories_not: String
  catogories_in: [String!]
  catogories_not_in: [String!]
  catogories_lt: String
  catogories_lte: String
  catogories_gt: String
  catogories_gte: String
  catogories_contains: String
  catogories_not_contains: String
  catogories_starts_with: String
  catogories_not_starts_with: String
  catogories_ends_with: String
  catogories_not_ends_with: String
  isVideo: Boolean
  isVideo_not: Boolean
  AND: [MediaScalarWhereInput!]
  OR: [MediaScalarWhereInput!]
  NOT: [MediaScalarWhereInput!]
}

type MediaSubscriptionPayload {
  mutation: MutationType!
  node: Media
  updatedFields: [String!]
  previousValues: MediaPreviousValues
}

input MediaSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MediaWhereInput
  AND: [MediaSubscriptionWhereInput!]
  OR: [MediaSubscriptionWhereInput!]
  NOT: [MediaSubscriptionWhereInput!]
}

input MediaUpdateDataInput {
  src: String
  caption: String
  catogories: String
  comments: CommentUpdateManyWithoutMediaInput
  submittedBy: UserUpdateOneWithoutMediaInput
  isVideo: Boolean
}

input MediaUpdateInput {
  src: String
  caption: String
  catogories: String
  comments: CommentUpdateManyWithoutMediaInput
  submittedBy: UserUpdateOneWithoutMediaInput
  isVideo: Boolean
}

input MediaUpdateManyDataInput {
  src: String
  caption: String
  catogories: String
  isVideo: Boolean
}

input MediaUpdateManyInput {
  create: [MediaCreateInput!]
  update: [MediaUpdateWithWhereUniqueNestedInput!]
  upsert: [MediaUpsertWithWhereUniqueNestedInput!]
  delete: [MediaWhereUniqueInput!]
  connect: [MediaWhereUniqueInput!]
  set: [MediaWhereUniqueInput!]
  disconnect: [MediaWhereUniqueInput!]
  deleteMany: [MediaScalarWhereInput!]
  updateMany: [MediaUpdateManyWithWhereNestedInput!]
}

input MediaUpdateManyMutationInput {
  src: String
  caption: String
  catogories: String
  isVideo: Boolean
}

input MediaUpdateManyWithoutSubmittedByInput {
  create: [MediaCreateWithoutSubmittedByInput!]
  delete: [MediaWhereUniqueInput!]
  connect: [MediaWhereUniqueInput!]
  set: [MediaWhereUniqueInput!]
  disconnect: [MediaWhereUniqueInput!]
  update: [MediaUpdateWithWhereUniqueWithoutSubmittedByInput!]
  upsert: [MediaUpsertWithWhereUniqueWithoutSubmittedByInput!]
  deleteMany: [MediaScalarWhereInput!]
  updateMany: [MediaUpdateManyWithWhereNestedInput!]
}

input MediaUpdateManyWithWhereNestedInput {
  where: MediaScalarWhereInput!
  data: MediaUpdateManyDataInput!
}

input MediaUpdateOneWithoutCommentsInput {
  create: MediaCreateWithoutCommentsInput
  update: MediaUpdateWithoutCommentsDataInput
  upsert: MediaUpsertWithoutCommentsInput
  delete: Boolean
  disconnect: Boolean
  connect: MediaWhereUniqueInput
}

input MediaUpdateWithoutCommentsDataInput {
  src: String
  caption: String
  catogories: String
  submittedBy: UserUpdateOneWithoutMediaInput
  isVideo: Boolean
}

input MediaUpdateWithoutSubmittedByDataInput {
  src: String
  caption: String
  catogories: String
  comments: CommentUpdateManyWithoutMediaInput
  isVideo: Boolean
}

input MediaUpdateWithWhereUniqueNestedInput {
  where: MediaWhereUniqueInput!
  data: MediaUpdateDataInput!
}

input MediaUpdateWithWhereUniqueWithoutSubmittedByInput {
  where: MediaWhereUniqueInput!
  data: MediaUpdateWithoutSubmittedByDataInput!
}

input MediaUpsertWithoutCommentsInput {
  update: MediaUpdateWithoutCommentsDataInput!
  create: MediaCreateWithoutCommentsInput!
}

input MediaUpsertWithWhereUniqueNestedInput {
  where: MediaWhereUniqueInput!
  update: MediaUpdateDataInput!
  create: MediaCreateInput!
}

input MediaUpsertWithWhereUniqueWithoutSubmittedByInput {
  where: MediaWhereUniqueInput!
  update: MediaUpdateWithoutSubmittedByDataInput!
  create: MediaCreateWithoutSubmittedByInput!
}

input MediaWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  src: String
  src_not: String
  src_in: [String!]
  src_not_in: [String!]
  src_lt: String
  src_lte: String
  src_gt: String
  src_gte: String
  src_contains: String
  src_not_contains: String
  src_starts_with: String
  src_not_starts_with: String
  src_ends_with: String
  src_not_ends_with: String
  caption: String
  caption_not: String
  caption_in: [String!]
  caption_not_in: [String!]
  caption_lt: String
  caption_lte: String
  caption_gt: String
  caption_gte: String
  caption_contains: String
  caption_not_contains: String
  caption_starts_with: String
  caption_not_starts_with: String
  caption_ends_with: String
  caption_not_ends_with: String
  catogories: String
  catogories_not: String
  catogories_in: [String!]
  catogories_not_in: [String!]
  catogories_lt: String
  catogories_lte: String
  catogories_gt: String
  catogories_gte: String
  catogories_contains: String
  catogories_not_contains: String
  catogories_starts_with: String
  catogories_not_starts_with: String
  catogories_ends_with: String
  catogories_not_ends_with: String
  comments_every: CommentWhereInput
  comments_some: CommentWhereInput
  comments_none: CommentWhereInput
  submittedBy: UserWhereInput
  isVideo: Boolean
  isVideo_not: Boolean
  AND: [MediaWhereInput!]
  OR: [MediaWhereInput!]
  NOT: [MediaWhereInput!]
}

input MediaWhereUniqueInput {
  id: ID
}

type Mutation {
  createComment(data: CommentCreateInput!): Comment!
  updateComment(data: CommentUpdateInput!, where: CommentWhereUniqueInput!): Comment
  updateManyComments(data: CommentUpdateManyMutationInput!, where: CommentWhereInput): BatchPayload!
  upsertComment(where: CommentWhereUniqueInput!, create: CommentCreateInput!, update: CommentUpdateInput!): Comment!
  deleteComment(where: CommentWhereUniqueInput!): Comment
  deleteManyComments(where: CommentWhereInput): BatchPayload!
  createGig(data: GigCreateInput!): Gig!
  updateGig(data: GigUpdateInput!, where: GigWhereUniqueInput!): Gig
  updateManyGigs(data: GigUpdateManyMutationInput!, where: GigWhereInput): BatchPayload!
  upsertGig(where: GigWhereUniqueInput!, create: GigCreateInput!, update: GigUpdateInput!): Gig!
  deleteGig(where: GigWhereUniqueInput!): Gig
  deleteManyGigs(where: GigWhereInput): BatchPayload!
  createMedia(data: MediaCreateInput!): Media!
  updateMedia(data: MediaUpdateInput!, where: MediaWhereUniqueInput!): Media
  updateManyMedias(data: MediaUpdateManyMutationInput!, where: MediaWhereInput): BatchPayload!
  upsertMedia(where: MediaWhereUniqueInput!, create: MediaCreateInput!, update: MediaUpdateInput!): Media!
  deleteMedia(where: MediaWhereUniqueInput!): Media
  deleteManyMedias(where: MediaWhereInput): BatchPayload!
  createPost(data: PostCreateInput!): Post!
  updatePost(data: PostUpdateInput!, where: PostWhereUniqueInput!): Post
  updateManyPosts(data: PostUpdateManyMutationInput!, where: PostWhereInput): BatchPayload!
  upsertPost(where: PostWhereUniqueInput!, create: PostCreateInput!, update: PostUpdateInput!): Post!
  deletePost(where: PostWhereUniqueInput!): Post
  deleteManyPosts(where: PostWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Post {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  title: String!
  content: String
  published: Boolean!
  author: User!
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment!]
}

type PostConnection {
  pageInfo: PageInfo!
  edges: [PostEdge]!
  aggregate: AggregatePost!
}

input PostCreateInput {
  id: ID
  title: String!
  content: String
  published: Boolean
  author: UserCreateOneWithoutPostsInput!
  comments: CommentCreateManyWithoutPostInput
}

input PostCreateManyWithoutAuthorInput {
  create: [PostCreateWithoutAuthorInput!]
  connect: [PostWhereUniqueInput!]
}

input PostCreateOneWithoutCommentsInput {
  create: PostCreateWithoutCommentsInput
  connect: PostWhereUniqueInput
}

input PostCreateWithoutAuthorInput {
  id: ID
  title: String!
  content: String
  published: Boolean
  comments: CommentCreateManyWithoutPostInput
}

input PostCreateWithoutCommentsInput {
  id: ID
  title: String!
  content: String
  published: Boolean
  author: UserCreateOneWithoutPostsInput!
}

type PostEdge {
  node: Post!
  cursor: String!
}

enum PostOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  title_ASC
  title_DESC
  content_ASC
  content_DESC
  published_ASC
  published_DESC
}

type PostPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  title: String!
  content: String
  published: Boolean!
}

input PostScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  published: Boolean
  published_not: Boolean
  AND: [PostScalarWhereInput!]
  OR: [PostScalarWhereInput!]
  NOT: [PostScalarWhereInput!]
}

type PostSubscriptionPayload {
  mutation: MutationType!
  node: Post
  updatedFields: [String!]
  previousValues: PostPreviousValues
}

input PostSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PostWhereInput
  AND: [PostSubscriptionWhereInput!]
  OR: [PostSubscriptionWhereInput!]
  NOT: [PostSubscriptionWhereInput!]
}

input PostUpdateInput {
  title: String
  content: String
  published: Boolean
  author: UserUpdateOneRequiredWithoutPostsInput
  comments: CommentUpdateManyWithoutPostInput
}

input PostUpdateManyDataInput {
  title: String
  content: String
  published: Boolean
}

input PostUpdateManyMutationInput {
  title: String
  content: String
  published: Boolean
}

input PostUpdateManyWithoutAuthorInput {
  create: [PostCreateWithoutAuthorInput!]
  delete: [PostWhereUniqueInput!]
  connect: [PostWhereUniqueInput!]
  set: [PostWhereUniqueInput!]
  disconnect: [PostWhereUniqueInput!]
  update: [PostUpdateWithWhereUniqueWithoutAuthorInput!]
  upsert: [PostUpsertWithWhereUniqueWithoutAuthorInput!]
  deleteMany: [PostScalarWhereInput!]
  updateMany: [PostUpdateManyWithWhereNestedInput!]
}

input PostUpdateManyWithWhereNestedInput {
  where: PostScalarWhereInput!
  data: PostUpdateManyDataInput!
}

input PostUpdateOneWithoutCommentsInput {
  create: PostCreateWithoutCommentsInput
  update: PostUpdateWithoutCommentsDataInput
  upsert: PostUpsertWithoutCommentsInput
  delete: Boolean
  disconnect: Boolean
  connect: PostWhereUniqueInput
}

input PostUpdateWithoutAuthorDataInput {
  title: String
  content: String
  published: Boolean
  comments: CommentUpdateManyWithoutPostInput
}

input PostUpdateWithoutCommentsDataInput {
  title: String
  content: String
  published: Boolean
  author: UserUpdateOneRequiredWithoutPostsInput
}

input PostUpdateWithWhereUniqueWithoutAuthorInput {
  where: PostWhereUniqueInput!
  data: PostUpdateWithoutAuthorDataInput!
}

input PostUpsertWithoutCommentsInput {
  update: PostUpdateWithoutCommentsDataInput!
  create: PostCreateWithoutCommentsInput!
}

input PostUpsertWithWhereUniqueWithoutAuthorInput {
  where: PostWhereUniqueInput!
  update: PostUpdateWithoutAuthorDataInput!
  create: PostCreateWithoutAuthorInput!
}

input PostWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  published: Boolean
  published_not: Boolean
  author: UserWhereInput
  comments_every: CommentWhereInput
  comments_some: CommentWhereInput
  comments_none: CommentWhereInput
  AND: [PostWhereInput!]
  OR: [PostWhereInput!]
  NOT: [PostWhereInput!]
}

input PostWhereUniqueInput {
  id: ID
}

type Query {
  comment(where: CommentWhereUniqueInput!): Comment
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment]!
  commentsConnection(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CommentConnection!
  gig(where: GigWhereUniqueInput!): Gig
  gigs(where: GigWhereInput, orderBy: GigOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Gig]!
  gigsConnection(where: GigWhereInput, orderBy: GigOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GigConnection!
  media(where: MediaWhereUniqueInput!): Media
  medias(where: MediaWhereInput, orderBy: MediaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Media]!
  mediasConnection(where: MediaWhereInput, orderBy: MediaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MediaConnection!
  post(where: PostWhereUniqueInput!): Post
  posts(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Post]!
  postsConnection(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PostConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Subscription {
  comment(where: CommentSubscriptionWhereInput): CommentSubscriptionPayload
  gig(where: GigSubscriptionWhereInput): GigSubscriptionPayload
  media(where: MediaSubscriptionWhereInput): MediaSubscriptionPayload
  post(where: PostSubscriptionWhereInput): PostSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  email: String!
  password: String!
  name: String
  posts(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Post!]
  media(where: MediaWhereInput, orderBy: MediaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Media!]
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment!]
  shows(where: GigWhereInput, orderBy: GigOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Gig!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  email: String!
  password: String!
  name: String
  posts: PostCreateManyWithoutAuthorInput
  media: MediaCreateManyWithoutSubmittedByInput
  comments: CommentCreateManyWithoutWrittenByInput
  shows: GigCreateManyWithoutParticipantsInput
}

input UserCreateManyWithoutShowsInput {
  create: [UserCreateWithoutShowsInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateOneWithoutCommentsInput {
  create: UserCreateWithoutCommentsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutMediaInput {
  create: UserCreateWithoutMediaInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutPostsInput {
  create: UserCreateWithoutPostsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutCommentsInput {
  id: ID
  email: String!
  password: String!
  name: String
  posts: PostCreateManyWithoutAuthorInput
  media: MediaCreateManyWithoutSubmittedByInput
  shows: GigCreateManyWithoutParticipantsInput
}

input UserCreateWithoutMediaInput {
  id: ID
  email: String!
  password: String!
  name: String
  posts: PostCreateManyWithoutAuthorInput
  comments: CommentCreateManyWithoutWrittenByInput
  shows: GigCreateManyWithoutParticipantsInput
}

input UserCreateWithoutPostsInput {
  id: ID
  email: String!
  password: String!
  name: String
  media: MediaCreateManyWithoutSubmittedByInput
  comments: CommentCreateManyWithoutWrittenByInput
  shows: GigCreateManyWithoutParticipantsInput
}

input UserCreateWithoutShowsInput {
  id: ID
  email: String!
  password: String!
  name: String
  posts: PostCreateManyWithoutAuthorInput
  media: MediaCreateManyWithoutSubmittedByInput
  comments: CommentCreateManyWithoutWrittenByInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  name_ASC
  name_DESC
}

type UserPreviousValues {
  id: ID!
  email: String!
  password: String!
  name: String
}

input UserScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  email: String
  password: String
  name: String
  posts: PostUpdateManyWithoutAuthorInput
  media: MediaUpdateManyWithoutSubmittedByInput
  comments: CommentUpdateManyWithoutWrittenByInput
  shows: GigUpdateManyWithoutParticipantsInput
}

input UserUpdateManyDataInput {
  email: String
  password: String
  name: String
}

input UserUpdateManyMutationInput {
  email: String
  password: String
  name: String
}

input UserUpdateManyWithoutShowsInput {
  create: [UserCreateWithoutShowsInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutShowsInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutShowsInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput!
  data: UserUpdateManyDataInput!
}

input UserUpdateOneRequiredWithoutCommentsInput {
  create: UserCreateWithoutCommentsInput
  update: UserUpdateWithoutCommentsDataInput
  upsert: UserUpsertWithoutCommentsInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutPostsInput {
  create: UserCreateWithoutPostsInput
  update: UserUpdateWithoutPostsDataInput
  upsert: UserUpsertWithoutPostsInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneWithoutMediaInput {
  create: UserCreateWithoutMediaInput
  update: UserUpdateWithoutMediaDataInput
  upsert: UserUpsertWithoutMediaInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutCommentsDataInput {
  email: String
  password: String
  name: String
  posts: PostUpdateManyWithoutAuthorInput
  media: MediaUpdateManyWithoutSubmittedByInput
  shows: GigUpdateManyWithoutParticipantsInput
}

input UserUpdateWithoutMediaDataInput {
  email: String
  password: String
  name: String
  posts: PostUpdateManyWithoutAuthorInput
  comments: CommentUpdateManyWithoutWrittenByInput
  shows: GigUpdateManyWithoutParticipantsInput
}

input UserUpdateWithoutPostsDataInput {
  email: String
  password: String
  name: String
  media: MediaUpdateManyWithoutSubmittedByInput
  comments: CommentUpdateManyWithoutWrittenByInput
  shows: GigUpdateManyWithoutParticipantsInput
}

input UserUpdateWithoutShowsDataInput {
  email: String
  password: String
  name: String
  posts: PostUpdateManyWithoutAuthorInput
  media: MediaUpdateManyWithoutSubmittedByInput
  comments: CommentUpdateManyWithoutWrittenByInput
}

input UserUpdateWithWhereUniqueWithoutShowsInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutShowsDataInput!
}

input UserUpsertWithoutCommentsInput {
  update: UserUpdateWithoutCommentsDataInput!
  create: UserCreateWithoutCommentsInput!
}

input UserUpsertWithoutMediaInput {
  update: UserUpdateWithoutMediaDataInput!
  create: UserCreateWithoutMediaInput!
}

input UserUpsertWithoutPostsInput {
  update: UserUpdateWithoutPostsDataInput!
  create: UserCreateWithoutPostsInput!
}

input UserUpsertWithWhereUniqueWithoutShowsInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutShowsDataInput!
  create: UserCreateWithoutShowsInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  posts_every: PostWhereInput
  posts_some: PostWhereInput
  posts_none: PostWhereInput
  media_every: MediaWhereInput
  media_some: MediaWhereInput
  media_none: MediaWhereInput
  comments_every: CommentWhereInput
  comments_some: CommentWhereInput
  comments_none: CommentWhereInput
  shows_every: GigWhereInput
  shows_some: GigWhereInput
  shows_none: GigWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
`
      }
    